# 4.2.3 Decision Table Testing

Decision tables are a good way to record complex business rules that a system must implement. When creating decision tables, the tester identifies conditions \(often inputs\) and the resulting actions \(often outputs\) of the system. These form the rows of the table, usually with the conditions at the top and the actions at the bottom. Each column corresponds to a decision rule that defines a unique combination of conditions which results in the execution of the actions associated with that rule. The values of the conditions and actions are usually shown as Boolean values \(true or false\) or discrete values \(e.g., red, green, blue\), but can also be numbers or ranges of numbers. These different types of conditions and actions might be found together in the same table.

The common notation in decision tables is as follows: 

For conditions: 

* Y means the condition is true \(may also be shown as T or 1\) 
* N means the condition is false \(may also be shown as F or 0\) 
* — means the value of the condition doesn’t matter \(may also be shown as N/A\)

For actions: 

* X means the action should occur \(may also be shown as Y or T or 1\) 
* Blank means the action should not occur \(may also be shown as – or N or F or 0\)

A full decision table has enough columns \(test cases\) to cover every combination of conditions. By deleting columns that do not affect the outcome, the number of test cases can decrease considerably. For example by removing impossible combinations of conditions. For more information on how to collapse decision tables. \(see ISTQB-CTAL-AT\). 

The common minimum coverage standard for decision table testing is to have at least one test case per decision rule in the table. This typically involves covering all combinations of conditions. Coverage is measured as the number of decision rules tested by at least one test case, divided by the total number of decision rules, normally expressed as a percentage. 

The strength of decision table testing is that it helps to identify all the important combinations of conditions, some of which might otherwise be overlooked. It also helps in finding any gaps in the requirements. It may be applied to all situations in which the behavior of the software depends on a combination of conditions, at any test level.



